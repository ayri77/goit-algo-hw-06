# goit-algo-hw-06

## Встановлення та запуск

### 1. Клонування репозиторію
```bash
git clone https://github.com/ayri77/goit-algo-hw-06.git
cd goit-algo-hw-06
```

### 2. Встановлення залежностей
```bash
pip install networkx pandas matplotlib numpy
```

### 3. Дані GTFS
Дані GTFS зберігаються в архіві `data/HVV_data.zip` для зменшення розміру репозиторію.

**Автоматичне розархівування:**
Дані автоматично розархівуються при першому запуску будь-якого завдання. 
Якщо потрібно розархівувати вручну:
```bash
# Windows PowerShell
Expand-Archive -Path data\HVV_data.zip -DestinationPath data\HVV -Force

# Linux/Mac
unzip data/HVV_data.zip -d data/HVV
```

### 4. Запуск завдань
```bash
# Завдання 1: Створення та візуалізація графа
python src/task1.py

# Завдання 2: DFS та BFS
python src/task2.py

# Завдання 3: Алгоритм Дейкстри
python src/task3.py
```

---

## Виконання завдання

### Завдання 1: Створення та візуалізація графа

**Реалізовано:**
- Створено граф транспортної мережі Гамбурга (HVV) за допомогою бібліотеки NetworkX
- Використано реальні дані GTFS (General Transit Feed Specification) для U-Bahn та S-Bahn
- Реалізовано об'єднання зупинок з однаковими назвами в один вузол (transfer stations)
- Візуалізовано граф з використанням географічних координат
- Додано легенду з маршрутами, використовуючи офіційні кольори ліній з GTFS
- Реалізовано візуальне розділення паралельних маршрутів (використання кривих ліній)

**Результати:**
- Граф містить 165 вузлів (станцій) та 183 ребра (зв'язки між станціями)
- Середня ступінь вершин: ~2.2
- Візуалізація показує повну мережу U-Bahn та S-Bahn з виділенням станцій пересадки

**Особливості реалізації:**
- Модульна структура коду (розділено на `data_loader`, `graph_builder`, `graph_analysis`, `visualization`)
- Обробка відсутніх кольорів маршрутів (використання значень за замовчуванням)
- Автоматичне визначення паралельних маршрутів та їх візуальне розділення

### Завдання 2: Алгоритми DFS та BFS

**Реалізовано:**
- Програмно реалізовано алгоритм DFS (Depth-First Search) з використанням стеку
- Програмно реалізовано алгоритм BFS (Breadth-First Search) з використанням черги
- Реалізовано функцію порівняння шляхів (`compare_paths`)
- Додано візуалізацію обох шляхів на графі з виділенням пересадок
- Реалізовано детальну легенду з описом маршрутів у форматі "Станція - Лінія - Станція"

**Результати порівняння:**
- BFS завжди знаходить найкоротший шлях за кількістю ребер (гарантовано для незваженого графа)
- DFS може знайти довший шлях, оскільки йде вглиб графа по першій доступній гілці
- На прикладі маршруту Stade → Ohlsdorf обидва алгоритми знайшли шляхи різної довжини

**Візуалізація:**
- DFS шлях відображається синьою суцільною лінією
- BFS шлях відображається червоною пунктирною лінією
- Виділяються тільки станції пересадки (оранжеві круги)
- Початкова та кінцева станції виділені зеленими та червоними зірками
- Інші станції маршруту тільки підписані без виділення

**Пояснення різниці:**
- **DFS** використовує стек (LIFO) і йде вглиб графа, досліджуючи один шлях до кінця. Не гарантує найкоротший шлях.
- **BFS** використовує чергу (FIFO) і йде вшир, досліджуючи всіх сусідів на кожному рівні. Гарантує найкоротший шлях за кількістю ребер.

### Завдання 3: Алгоритм Дейкстри

**Реалізовано:**
- Програмно реалізовано алгоритм Дейкстри для знаходження найкоротшого шляху
- Реалізовано два методи розрахунку ваг ребер:
  1. **Географічна відстань** - використання формули Haversine для розрахунку відстані між координатами станцій
  2. **Час в дорозі** - використання даних з GTFS розкладу (arrival_time, departure_time)
- Реалізовано функцію для знаходження всіх пар найкоротших шляхів
- Додано детальну статистику по всіх парах вершин

**Результати:**
- Для графа з 165 вузлами знайдено 13,530 унікальних пар шляхів
- Статистика для географічної відстані:
  - Мінімальна відстань: 241 м (між найближчими станціями)
  - Максимальна відстань: 78.57 км
  - Середня відстань: 18.43 км
- Приклад маршруту Stade → Ohlsdorf: 28 станцій, загальна відстань 61.66 км

**Особливості реалізації:**
- Парсинг часу з GTFS формату (HH:MM:SS) в секунди
- Обробка переходу через північ у розкладах
- Збереження множини часів для кожного ребра (для різних рейсів)
- Використання мінімального часу для кожного ребра при розрахунку ваг

**Структура проекту:**
```
src/
├── graph_utils/
│   ├── data_loader.py      # Завантаження GTFS даних
│   ├── graph_builder.py    # Побудова графа з GTFS
│   ├── graph_analysis.py   # Аналіз характеристик графа
│   ├── visualization.py    # Візуалізація графа та маршрутів
│   ├── pathfinding.py      # Алгоритми DFS та BFS
│   └── dijkstra.py         # Алгоритм Дейкстри та розрахунок ваг
├── task1.py                # Завдання 1: Створення та візуалізація
├── task2.py                # Завдання 2: DFS та BFS
└── task3.py                # Завдання 3: Алгоритм Дейкстри
```

**Технології:**
- Python 3.x
- NetworkX - для роботи з графами
- Pandas - для обробки GTFS даних
- Matplotlib - для візуалізації
- NumPy - для математичних обчислень

**Дані:**
- Використано реальні дані GTFS транспортної мережі Гамбурга (HVV)
- Дані містять інформацію про U-Bahn (метро) та S-Bahn (міська електричка)
- Всього оброблено тисячі зупинок та рейсів з офіційного розкладу